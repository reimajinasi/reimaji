# Task 1.2: Implement User Role Management

## Status: ‚è≥ In Progress

## Overview
Implementasi sistem manajemen peran pengguna untuk platform Reimaji, termasuk admin panel untuk manajemen user, flow upgrade dari Free ke Pro, dan session management yang aman.

---

## ‚úÖ Acceptance Criteria

### 1.2.1 Admin Panel for User Management
- [ ] Halaman admin dashboard dengan overview user statistics
- [ ] Tabel user dengan filtering dan sorting (nama, email, role, status)
- [ ] Bulk actions untuk update role multiple user sekaligus
- [ ] User detail page dengan informasi lengkap dan activity log
- [ ] Export user data ke CSV/Excel
- [ ] Search user berdasarkan nama atau email (real-time)
- [ ] Ban/unban user functionality dengan alasan
- [ ] Role assignment dengan konfirmasi dan audit trail

### 1.2.2 Role Upgrade Flow (Free to Pro)
- [ ] Halaman upgrade subscription dengan benefit comparison
- [ ] Integrasi dengan payment gateway (Xendit) untuk pembayaran
- [ ] Pro upgrade instant setelah pembayaran sukses
- [ ] Email notification untuk upgrade confirmation
- [ ] Downgrade flow dengan konfirmasi dan feedback
- [ ] Grace period 7 hari untuk Pro features sebelum downgrade
- [ ] Upgrade history dan billing information di profile
- [ ] Promo code system untuk discount

### 1.2.3 User Session Management
- [ ] Session timeout setelah 30 menit inaktivitas
- [ ] Multiple device login dengan limit 3 device per user
- [ ] Force logout dari semua device
- [ ] Session history di user profile
- [ ] Remember me functionality (30 hari)
- [ ] Secure session token rotation
- [ ] Login attempt limiting (5x gagal = 15 menit lockout)
- [ ] Two-factor authentication untuk Pro users

---

## üìù Langkah Implementasi

### Fase 1: Role System Architecture
1. **Define User Roles & Permissions**
   ```typescript
   // convex/schema.ts
   export const userRoles = {
     FREE: {
       name: "Free User",
       permissions: [
         "read:news",
         "read:research",
         "read:courses",
         "complete:basic-courses",
         "comment:limited"
       ],
       limits: {
         dailyArticles: 10,
         monthlyCourses: 2,
         commentsPerDay: 5,
         aiPlaygroundRequests: 10
       }
     },
     PRO: {
       name: "Pro User",
       permissions: [
         "read:news",
         "read:research",
         "read:courses",
         "complete:all-courses",
         "comment:unlimited",
         "download:resources",
         "priority:support",
         "ai:advanced"
       ],
       limits: {
         dailyArticles: -1, // unlimited
         monthlyCourses: -1,
         commentsPerDay: -1,
         aiPlaygroundRequests: 100
       }
     },
     ADMIN: {
       name: "Admin",
       permissions: ["*"], // all permissions
       limits: {}
     },
     SUPERADMIN: {
       name: "Super Admin",
       permissions: ["*"],
       limits: {}
     }
   };
   ```

2. **Convex Schema Update**
   ```typescript
   // convex/schema.ts
   export default defineSchema({
     users: defineTable({
       clerkId: v.string(),
       email: v.string(),
       firstName: v.string(),
       lastName: v.string(),
       role: v.union(v.literal("FREE"), v.literal("PRO"), v.literal("ADMIN"), v.literal("SUPERADMIN")),
       status: v.union(v.literal("active"), v.literal("banned"), v.literal("suspended")),
       subscriptionId: v.optional(v.string()),
       subscriptionEndDate: v.optional(v.number()),
       metadata: v.object({
         lastLoginAt: v.optional(v.number()),
         loginCount: v.number(),
         failedLoginAttempts: v.number(),
         lockedUntil: v.optional(v.number()),
         upgradeHistory: v.array(v.object({
           from: v.string(),
           to: v.string(),
           date: v.number(),
           reason: v.string()
         }))
       }),
       createdAt: v.number(),
       updatedAt: v.number()
     })
     .index("by_clerk_id", ["clerkId"])
     .index("by_email", ["email"])
     .index("by_role", ["role"])
     .index("by_status", ["status"]),

     sessions: defineTable({
       userId: v.string(),
       sessionToken: v.string(),
       deviceInfo: v.object({
         userAgent: v.string(),
         ipAddress: v.string(),
         deviceType: v.string()
       }),
       expiresAt: v.number(),
       isActive: v.boolean(),
       createdAt: v.number()
     })
     .index("by_user_id", ["userId"])
     .index("by_session_token", ["sessionToken"])
     .index("by_expires_at", ["expiresAt"]),

     auditLogs: defineTable({
       userId: v.string(),
       action: v.string(),
       resource: v.string(),
       metadata: v.optional(v.object({})),
       ipAddress: v.string(),
       userAgent: v.string(),
       createdAt: v.number()
     })
     .index("by_user_id", ["userId"])
     .index("by_action", ["action"])
     .index("by_created_at", ["createdAt"])
   });
   ```

### Fase 2: Admin Panel Development
1. **Admin Dashboard Layout**
   ```typescript
   // app/admin/layout.tsx
   import { AdminNav } from "@/components/layout/admin-nav";
   import { requireAdminRole } from "@/lib/auth";
   
   export default async function AdminLayout({
     children,
   }: {
     children: React.ReactNode;
   }) {
     // Verify admin role
     await requireAdminRole();
     
     return (
       <div className="flex h-screen">
         <AdminNav />
         <main className="flex-1 overflow-y-auto bg-gray-50">
           <div className="container mx-auto p-6">
             {children}
           </div>
         </main>
       </div>
     );
   }
   ```

2. **User Management Table**
   ```typescript
   // app/admin/users/page.tsx
   import { DataTable } from "@/components/ui/data-table";
   import { useQuery } from "convex/react";
   import { api } from "@/convex/_generated/api";
   import { UserActions } from "@/components/admin/user-actions";
   
   const columns = [
     {
       accessorKey: "name",
       header: "Nama",
       cell: ({ row }) => (
         <div>
           <div className="font-medium">{row.original.firstName} {row.original.lastName}</div>
           <div className="text-sm text-gray-500">{row.original.email}</div>
         </div>
       )
     },
     {
       accessorKey: "role",
       header: "Role",
       cell: ({ row }) => (
         <Badge variant={getRoleBadgeVariant(row.original.role)}>
           {row.original.role}
         </Badge>
       )
     },
     {
       accessorKey: "status",
       header: "Status",
       cell: ({ row }) => (
         <Badge variant={getStatusBadgeVariant(row.original.status)}>
           {row.original.status}
         </Badge>
       )
     },
     {
       accessorKey: "lastLoginAt",
       header: "Last Login",
       cell: ({ row }) => (
         <div className="text-sm text-gray-500">
           {row.original.metadata?.lastLoginAt 
             ? formatDate(row.original.metadata.lastLoginAt)
             : "Never"}
         </div>
       )
     },
     {
       id: "actions",
       cell: ({ row }) => <UserActions user={row.original} />
     }
   ];
   
   export default function AdminUsersPage() {
     const { data: users, isLoading } = useQuery(api.users.list, {
       limit: 50,
       offset: 0
     });
     
     return (
       <div>
         <div className="mb-6">
           <h1 className="text-2xl font-bold">User Management</h1>
           <p className="text-gray-600">Kelola pengguna dan role mereka</p>
         </div>
         
         <Card>
           <CardHeader>
             <div className="flex justify-between items-center">
               <CardTitle>Daftar Pengguna</CardTitle>
               <div className="flex gap-2">
                 <Input placeholder="Cari user..." className="max-w-sm" />
                 <Button variant="outline">
                   <Download className="w-4 h-4 mr-2" />
                   Export
                 </Button>
               </div>
             </div>
           </CardHeader>
           <CardContent>
             <DataTable columns={columns} data={users || []} loading={isLoading} />
           </CardContent>
         </Card>
       </div>
     );
   }
   ```

3. **User Actions Component**
   ```typescript
   // components/admin/user-actions.tsx
   import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
   import { Button } from "@/components/ui/button";
   import { MoreHorizontal, UserX, UserCheck, Shield, ArrowUpDown } from "lucide-react";
   import { useMutation } from "convex/react";
   import { api } from "@/convex/_generated/api";
   import { useToast } from "@/components/ui/use-toast";
   
   interface UserActionsProps {
     user: any;
   }
   
   export function UserActions({ user }: UserActionsProps) {
     const { toast } = useToast();
     const updateRole = useMutation(api.users.updateRole);
     const updateStatus = useMutation(api.users.updateStatus);
     
     const handleRoleChange = async (newRole: string) => {
       try {
         await updateRole({
           userId: user._id,
           role: newRole,
           reason: "Admin role change"
         });
         
         toast({
           title: "Role diperbarui",
           description: `User ${user.email} sekarang menjadi ${newRole}`
         });
       } catch (error) {
         toast({
           title: "Error",
           description: "Gagal mengubah role user",
           variant: "destructive"
         });
       }
     };
     
     const handleStatusToggle = async () => {
       try {
         const newStatus = user.status === "active" ? "banned" : "active";
         await updateStatus({
           userId: user._id,
           status: newStatus,
           reason: "Admin status change"
         });
         
         toast({
           title: "Status diperbarui",
           description: `User ${user.email} ${newStatus === "active" ? "diaktifkan" : "diblokir"}`
         });
       } catch (error) {
         toast({
           title: "Error",
           description: "Gagal mengubah status user",
           variant: "destructive"
         });
       }
     };
     
     return (
       <DropdownMenu>
         <DropdownMenuTrigger asChild>
           <Button variant="ghost" size="sm">
             <MoreHorizontal className="w-4 h-4" />
           </Button>
         </DropdownMenuTrigger>
         <DropdownMenuContent align="end">
           <DropdownMenuItem onClick={handleStatusToggle}>
             {user.status === "active" ? (
               <>
                 <UserX className="w-4 h-4 mr-2" />
                 Ban User
               </>
             ) : (
               <>
                 <UserCheck className="w-4 h-4 mr-2" />
                 Unban User
               </>
             )}
           </DropdownMenuItem>
           
           <DropdownMenuItem onClick={() => handleRoleChange("ADMIN")}>
             <Shield className="w-4 h-4 mr-2" />
             Jadikan Admin
           </DropdownMenuItem>
           
           <DropdownMenuItem onClick={() => handleRoleChange("PRO")}>
             <ArrowUpDown className="w-4 h-4 mr-2" />
             Upgrade ke Pro
           </DropdownMenuItem>
         </DropdownMenuContent>
       </DropdownMenu>
     );
   }
   ```

### Fase 3: Subscription & Upgrade Flow
1. **Upgrade Page with Benefits**
   ```typescript
   // app/(app)/upgrade/page.tsx
   import { Check, X } from "lucide-react";
   import { Button } from "@/components/ui/button";
   import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
   import { createSubscription } from "@/lib/xendit";
   
   const features = [
     {
       name: "Akses Artikel",
       free: "10 artikel/hari",
       pro: "Akses unlimited"
     },
     {
       name: "Kursus Premium",
       free: "2 kursus/bulan",
       pro: "Semua kursus tersedia"
     },
     {
       name: "AI Playground",
       free: "10 requests/bulan",
       pro: "100 requests/bulan"
     },
     {
       name: "Support",
       free: "Email support",
       pro: "Priority support + Live chat"
     },
     {
       name: "Download Resources",
       free: <X className="w-4 h-4 text-red-500" />,
       pro: <Check className="w-4 h-4 text-green-500" />
     },
     {
       name: "Advanced Analytics",
       free: <X className="w-4 h-4 text-red-500" />,
       pro: <Check className="w-4 h-4 text-green-500" />
     }
   ];
   
   export default function UpgradePage() {
     const handleUpgrade = async () => {
       try {
         const { invoiceUrl } = await createSubscription({
           plan: "pro_monthly",
           price: 99000, // IDR 99.000
           userId: user.id
         });
         
         // Redirect to Xendit payment page
         window.location.href = invoiceUrl;
       } catch (error) {
         console.error("Error creating subscription:", error);
       }
     };
     
     return (
       <div className="container mx-auto py-8 max-w-6xl">
         <div className="text-center mb-12">
           <h1 className="text-3xl font-bold mb-4">Upgrade ke Pro</h1>
           <p className="text-gray-600 text-lg">
             Dapatkan akses penuh ke semua fitur Reimaji dan akselerasi pembelajaran AI kamu
           </p>
         </div>
         
         <div className="grid md:grid-cols-2 gap-8 max-w-4xl mx-auto">
           {/* Free Plan */}
           <Card>
             <CardHeader>
               <CardTitle>Free Plan</CardTitle>
               <div className="text-3xl font-bold">Rp 0</div>
               <div className="text-gray-500">Selamanya</div>
             </CardHeader>
             <CardContent>
               <ul className="space-y-3">
                 {features.map((feature, index) => (
                   <li key={index} className="flex justify-between items-center">
                     <span>{feature.name}</span>
                     <span className="text-sm">{feature.free}</span>
                   </li>
                 ))}
               </ul>
               <Button className="w-full mt-6" variant="outline" disabled>
                 Plan Saat Ini
               </Button>
             </CardContent>
           </Card>
           
           {/* Pro Plan */}
           <Card className="border-blue-500 border-2">
             <CardHeader>
               <CardTitle>Pro Plan</CardTitle>
               <div className="text-3xl font-bold">Rp 99.000</div>
               <div className="text-gray-500">Per bulan</div>
             </CardHeader>
             <CardContent>
               <ul className="space-y-3">
                 {features.map((feature, index) => (
                   <li key={index} className="flex justify-between items-center">
                     <span>{feature.name}</span>
                     <span>{feature.pro}</span>
                   </li>
                 ))}
               </ul>
               <Button className="w-full mt-6" onClick={handleUpgrade}>
                 Upgrade Sekarang
               </Button>
             </CardContent>
           </Card>
         </div>
       </div>
     );
   }
   ```

2. **Xendit Integration**
   ```typescript
   // lib/xendit.ts
   import Xendit from "xendit-node";
   
   const xenditClient = new Xendit({
     secretKey: process.env.XENDIT_SECRET_KEY!,
   });
   
   export async function createSubscription({
     plan,
     price,
     userId,
     promoCode
   }: {
     plan: string;
     price: number;
     userId: string;
     promoCode?: string;
   }) {
     try {
       // Apply promo code if provided
       let finalPrice = price;
       if (promoCode) {
         const discount = await validatePromoCode(promoCode);
         finalPrice = price - (price * discount / 100);
       }
       
       // Create invoice
       const invoice = await xenditClient.Invoice.createInvoice({
         externalID: `subscription_${userId}_${Date.now()}`,
         amount: finalPrice,
         payerEmail: user.email,
         description: `Reimaji ${plan} Subscription`,
         successRedirectURL: `${process.env.NEXT_PUBLIC_APP_URL}/payment/success`,
         failureRedirectURL: `${process.env.NEXT_PUBLIC_APP_URL}/payment/failed`,
         currency: "IDR",
         invoiceDuration: 86400, // 24 hours
         shouldSendEmail: true,
         customer: {
           given_names: user.firstName,
           surname: user.lastName,
           email: user.email
         }
       });
       
       // Store pending subscription in database
       await convex.mutation(api.subscriptions.createPending, {
         userId,
         invoiceId: invoice.id,
         plan,
         amount: finalPrice,
         promoCode
       });
       
       return {
         invoiceUrl: invoice.invoiceUrl,
         invoiceId: invoice.id
       };
     } catch (error) {
       console.error("Error creating Xendit invoice:", error);
       throw new Error("Failed to create subscription");
     }
   }
   ```

### Fase 4: Session Management & Security
1. **Session Management**
   ```typescript
   // convex/users.ts
   import { mutation, query, action } from "./_generated/server";
   import { v } from "convex/values";
   
   export const createSession = mutation({
     args: {
       userId: v.string(),
       deviceInfo: v.object({
         userAgent: v.string(),
         ipAddress: v.string(),
         deviceType: v.string()
       }),
       expiresAt: v.number()
     },
     handler: async (ctx, args) => {
       // Check existing sessions
       const existingSessions = await ctx.db
         .query("sessions")
         .withIndex("by_user_id", (q) => q.eq("userId", args.userId))
         .filter((q) => q.eq(q.field("isActive"), true))
         .collect();
       
       // Limit to 3 active sessions per user
       if (existingSessions.length >= 3) {
         // Deactivate oldest session
         const oldestSession = existingSessions.sort((a, b) => 
           a.createdAt - b.createdAt
         )[0];
         
         await ctx.db.patch(oldestSession._id, {
           isActive: false
         });
       }
       
       // Create new session
       const session = await ctx.db.insert("sessions", {
         userId: args.userId,
         sessionToken: generateSessionToken(),
         deviceInfo: args.deviceInfo,
         expiresAt: args.expiresAt,
         isActive: true,
         createdAt: Date.now()
       });
       
       return session;
     }
   });
   
   export const validateSession = query({
     args: {
       sessionToken: v.string()
     },
     handler: async (ctx, args) => {
       const session = await ctx.db
         .query("sessions")
         .withIndex("by_session_token", (q) => 
           q.eq("sessionToken", args.sessionToken)
         )
         .first();
       
       if (!session || !session.isActive) {
         return null;
       }
       
       // Check if session is expired
       if (Date.now() > session.expiresAt) {
         await ctx.db.patch(session._id, {
           isActive: false
         });
         return null;
       }
       
       // Update last activity
       await ctx.db.patch(session._id, {
         lastActivityAt: Date.now()
       });
       
       return session;
     }
   });
   ```

2. **Login Attempt Limiting**
   ```typescript
   // convex/users.ts
   export const handleLoginAttempt = mutation({
     args: {
       email: v.string(),
       success: v.boolean(),
       ipAddress: v.string()
     },
     handler: async (ctx, args) => {
       const user = await ctx.db
         .query("users")
         .withIndex("by_email", (q) => q.eq("email", args.email))
         .first();
       
       if (!user) return;
       
       if (args.success) {
         // Reset failed attempts on successful login
         await ctx.db.patch(user._id, {
           "metadata.failedLoginAttempts": 0,
           "metadata.lockedUntil": null,
           "metadata.lastLoginAt": Date.now()
         });
       } else {
         // Increment failed attempts
         const failedAttempts = (user.metadata?.failedLoginAttempts || 0) + 1;
         
         if (failedAttempts >= 5) {
           // Lock account for 15 minutes
           await ctx.db.patch(user._id, {
             "metadata.failedLoginAttempts": failedAttempts,
             "metadata.lockedUntil": Date.now() + (15 * 60 * 1000) // 15 minutes
           });
           
           // Log security event
           await ctx.db.insert("auditLogs", {
             userId: user._id,
             action: "ACCOUNT_LOCKED",
             resource: "USER",
             metadata: {
               reason: "Too many failed login attempts",
               failedAttempts,
               ipAddress: args.ipAddress
             },
             ipAddress: args.ipAddress,
             userAgent: ctx.headers.get("user-agent") || "",
             createdAt: Date.now()
           });
         } else {
           await ctx.db.patch(user._id, {
             "metadata.failedLoginAttempts": failedAttempts
           });
         }
       }
     }
   });
   ```

---

## üîç Verifikasi & Testing

### Unit Testing
```typescript
// __tests__/admin/user-management.test.ts
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import AdminUsersPage from "@/app/admin/users/page";
import { useQuery, useMutation } from "convex/react";

jest.mock("convex/react");

describe("Admin User Management", () => {
  it("should display user list with correct information", () => {
    const mockUsers = [
      {
        _id: "1",
        firstName: "John",
        lastName: "Doe",
        email: "john@example.com",
        role: "FREE",
        status: "active",
        metadata: { lastLoginAt: Date.now() - 86400000 } // 1 day ago
      }
    ];
    
    (useQuery as jest.Mock).mockReturnValue({ data: mockUsers, isLoading: false });
    
    render(<AdminUsersPage />);
    
    expect(screen.getByText("John Doe")).toBeInTheDocument();
    expect(screen.getByText("john@example.com")).toBeInTheDocument();
    expect(screen.getByText("FREE")).toBeInTheDocument();
    expect(screen.getByText("active")).toBeInTheDocument();
  });
  
  it("should handle role change correctly", async () => {
    const mockUpdateRole = jest.fn().mockResolvedValue({});
    (useMutation as jest.Mock).mockReturnValue(mockUpdateRole);
    
    render(<UserActions user={{ _id: "1", email: "test@example.com", status: "active" }} />);
    
    fireEvent.click(screen.getByRole("button"));
    fireEvent.click(screen.getByText("Jadikan Admin"));
    
    await waitFor(() => {
      expect(mockUpdateRole).toHaveBeenCalledWith({
        userId: "1",
        role: "ADMIN",
        reason: "Admin role change"
      });
    });
  });
});
```

### Integration Testing
```typescript
// __tests__/subscription/upgrade-flow.test.ts
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import UpgradePage from "@/app/(app)/upgrade/page";
import { createSubscription } from "@/lib/xendit";

jest.mock("@/lib/xendit");

describe("Subscription Upgrade Flow", () => {
  it("should redirect to payment page on upgrade", async () => {
    const mockCreateSubscription = jest.fn().mockResolvedValue({
      invoiceUrl: "https://checkout.xendit.com/123",
      invoiceId: "invoice_123"
    });
    
    (createSubscription as jest.Mock).mockImplementation(mockCreateSubscription);
    
    // Mock window.location
    const mockLocation = { href: "" };
    delete window.location;
    window.location = mockLocation as any;
    
    render(<UpgradePage />);
    
    fireEvent.click(screen.getByText("Upgrade Sekarang"));
    
    await waitFor(() => {
      expect(mockCreateSubscription).toHaveBeenCalledWith({
        plan: "pro_monthly",
        price: 99000,
        userId: expect.any(String)
      });
      expect(window.location.href).toBe("https://checkout.xendit.com/123");
    });
  });
});
```

### E2E Testing
```typescript
// playwright/admin-user-management.spec.ts
import { test, expect } from "@playwright/test";

test.describe("Admin User Management", () => {
  test("admin can view and manage users", async ({ page }) => {
    // Login as admin
    await page.goto("/sign-in");
    await page.fill('input[type="email"]', "admin@example.com");
    await page.fill('input[type="password"]', "password123");
    await page.click('button[type="submit"]');
    
    // Navigate to admin users page
    await page.goto("/admin/users");
    
    // Should see user list
    await expect(page.locator("h1")).toContainText("User Management");
    await expect(page.locator("text=john@example.com")).toBeVisible();
    
    // Test search functionality
    await page.fill('input[placeholder="Cari user..."]', "john");
    await expect(page.locator("text=john@example.com")).toBeVisible();
    
    // Test role change
    await page.click('button:has-text("More")').first();
    await page.click('text="Jadikan Admin"');
    
    // Should show success toast
    await expect(page.locator("text=Role diperbarui")).toBeVisible();
    
    // Verify role change in UI
    await expect(page.locator("text=ADMIN")).toBeVisible();
  });
  
  test("session management works correctly", async ({ page }) => {
    // Login from device 1
    await page.goto("/sign-in");
    await page.fill('input[type="email"]', "test@example.com");
    await page.fill('input[type="password"]', "password123");
    await page.click('button[type="submit"]');
    
    // Should be logged in successfully
    await expect(page).toHaveURL("/dashboard");
    
    // Simulate login from device 2 (different browser context)
    const context2 = await browser.newContext();
    const page2 = await context2.newPage();
    
    await page2.goto("/sign-in");
    await page2.fill('input[type="email"]', "test@example.com");
    await page2.fill('input[type="password"]', "password123");
    await page2.click('button[type="submit"]');
    
    // Should also be logged in
    await expect(page2).toHaveURL("/dashboard");
    
    // Try to login from device 4 (should kick out device 1)
    const context4 = await browser.newContext();
    const page4 = await context4.newPage();
    
    await page4.goto("/sign-in");
    await page4.fill('input[type="email"]', "test@example.com");
    await page4.fill('input[type="password"]', "password123");
    await page4.click('button[type="submit"]');
    
    // Device 1 should be logged out
    await page.reload();
    await expect(page).toHaveURL("/sign-in");
    
    await context2.close();
    await context4.close();
  });
});
```

---

## ‚ö†Ô∏è Risiko & Mitigasi

### Risiko Utama
1. **Unauthorized Admin Access**
   - **Dampak**: Admin privileges bisa disalahgunakan
   - **Mitigasi**: Implement proper role checking, audit all admin actions, require re-authentication for critical actions
   - **Monitoring**: Log all admin actions, setup alerts for suspicious admin activity, regular access reviews

2. **Payment Processing Issues**
   - **Dampak**: User tidak bisa upgrade, revenue loss
   - **Mitigasi**: Implement payment retry logic, multiple payment methods, manual upgrade option for support
   - **Monitoring**: Track payment success rates, setup alerts for payment failures >10%, monitor Xendit API health

3. **Session Security Breach**
   - **Dampak**: Unauthorized access ke user accounts
   - **Mitigasi**: Implement secure session token generation, regular token rotation, suspicious activity detection
   - **Monitoring**: Track concurrent logins, setup alerts for unusual login patterns, monitor failed login attempts

4. **Role Escalation Vulnerabilities**
   - **Dampak**: User bisa mendapatkan akses yang tidak seharusnya
   - **Mitigasi**: Server-side permission validation, never trust client-side role checks, regular security audits
   - **Monitoring**: Audit role changes, track permission usage, setup alerts for privilege escalation attempts

5. **Data Consistency Issues**
   - **Dampak**: Role/permission data tidak sinkron antara services
   - **Mitigasi**: Implement transactional updates, webhook handlers untuk Clerk events, regular data reconciliation
   - **Monitoring**: Track data sync failures, setup alerts untuk data inconsistency, audit trail untuk semua perubahan

---

## üìã Checklist Pengerjaan

### Hari 1-2: Role System Setup
- [ ] Define user roles dan permissions di Convex schema
- [ ] Update database schema dengan tables baru
- [ ] Create permission checking utilities
- [ ] Test basic role validation

### Hari 3-4: Admin Panel Development
- [ ] Create admin layout dan navigation
- [ ] Implement user management table dengan filtering
- [ ] Add user search dan bulk actions
- [ ] Create user detail page dengan activity log

### Hari 5-6: Subscription Integration
- [ ] Design upgrade page dengan benefit comparison
- [ ] Integrasi Xendit untuk payment processing
- [ ] Implement subscription webhook handlers
- [ ] Create email notifications untuk upgrade

### Hari 7-8: Session Management
- [ ] Implement session creation dan validation
- [ ] Add login attempt limiting dan account lockout
- [ ] Create session history di user profile
- [ ] Implement force logout functionality

### Hari 9-10: Security & Testing
- [ ] Add 2FA untuk Pro users
- [ ] Implement secure token rotation
- [ ] Write comprehensive tests untuk semua flows
- [ ] Perform security audit dan penetration testing

---

## üîó Dependencies

### External Services
- **Clerk**: User authentication dan role management
- **Xendit**: Payment processing untuk subscription
- **Convex**: User data dan session storage
- **Resend**: Email notifications untuk role changes

### Internal Dependencies
- Authentication system dari Task 1.1
- UI components dari design system
- Payment integration utilities
- Audit logging system

---

## üìä Success Metrics

- **Admin Efficiency**: Target <2 detik untuk user role changes
- **Payment Success**: Target 95% success rate untuk Pro upgrades
- **Security**: Target 0 unauthorized role escalations
- **User Experience**: Target <3 detik untuk semua admin operations
- **Session Security**: Target <0.1% session hijacking incidents